#pragma once
#include "Logical.hpp"

namespace Logical
{

namespace Internal
{
    const ShortIndex P = 317;

    template<typename Arity>
    Int Hash(Arity, Int i) { return i; }

    template<typename Arity, typename...Ints>
    Int Hash(Arity a, Int i, Ints... is)
    {
        return i + P * Hash(a, is...);
    }

    template<bool...Binding>
    struct HashHelper;

    template<>
    struct HashHelper<>
    {
        static Int Hash() { return 0; }
        static Int Hash(const Int * row) { return 0; }
    };

    template<bool...Binding>
    struct HashHelper<true, Binding...>
    {
        template<typename...Ints>
        static Int Hash(Int i, Ints... is) { return i + P * HashHelper<Binding...>::Hash(is...); }
        static Int Hash(const Int * row) { return *row + P * HashHelper<Binding...>::Hash(row+1); }
    };

    template<bool...Binding>
    struct HashHelper<false, Binding...>
    {
        template<typename...Ints>
        static Int Hash(Int i, Ints... is) { return HashHelper<Binding...>::Hash(is...); }
        static Int Hash(const Int * row) { return HashHelper<Binding...>::Hash(row+1); }
    };

    template<bool...Bound, typename...Ints>
    Int BoundHashI(Ints... is) { return HashHelper<Bound...>::Hash(is...); }

    template<bool...Bound>
    Int BoundHashI(const Int * row) { return HashHelper<Bound...>::Hash(row); }

    inline Int BoundHash(DynamicBinding b, const Int * row)
    {
        Int h=0;
        Int mul = 1;
        for(auto m = b.mask; m; row++, m>>=1)
        {
            if(m&1) { h += mul * *row; mul = mul*P; }
        }
        return h;
    }

    template<bool...Bs>
    Int BoundHash(StaticBinding<Bs...> b, const Int * row)
    {
        return HashHelper<Bs...>::Hash(row);
    }

    template<bool...Bs, typename...Ints>
    Int BoundHash(StaticBinding<Bs...> b, Ints...is)
    {
        return HashHelper<Bs...>::Hash(is...);
    }

    inline Int HashWithMask(Int m) { return 0; }

    template<typename...Ints>
    Int HashWithMask(Int m, Int i, Ints...is)
    {
        return (m&1)? i + P * HashWithMask(m>>1, is...) : HashWithMask(m>>1, is...);
    }

    template<typename...Ints>
    Int BoundHash(DynamicBinding b, Int i, Ints...is)
    {
        return HashWithMask(b.mask, i, is...);
    }

    template<typename Arity>
    Int Hash(Arity arity, const Int *p)
    {
        Int h = 0;
        Int mul = 1;
        for(int i=0; i<arity.value; ++i, mul*=P)
            h += mul*p[i];
        return h;
    }

    inline Int Hash(DynamicArity) { return 0; }

    inline Int Hash(StaticArity<0>) { return 0; }

    static const ShortIndex EmptyCell = -1;

    inline void FirstHash(Enumerator & e, Int h)
    {
        e.i = h;
        e.j = 1;
    }

    inline void NextHash(Enumerator &e)
    {
        ++e.j;
    }

    inline ShortIndex GetIndex(const Enumerator &e, ShortIndex s)
    {
        return (e.i + e.j * e.j) % s;
    }

    inline ShortIndex GetIndexSize(int index)
    {
        // Generated by the accompanying primegenerator.cpp program
        static ShortIndex sizes[] = { 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 
            262139, 524287, 1048573, 2097143, 4194301, 8388593, 16777213, 33554393, 67108859, 134217689, 
            268435399, 536870909, 1073741789, 2147483647 };
        return sizes[index];
    }
}
}
